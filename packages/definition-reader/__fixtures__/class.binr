#name "CLASS Format (Java Bytecode)"
#extension ".class"

enum ConstantPoolTag {
    TAG_UTF8                = 1,
    TAG_INTEGER             = 3,
    TAG_FLOAT               = 4,
    TAG_LONG                = 5,
    TAG_DOUBLE              = 6,
    TAG_CLASS               = 7,
    TAG_STRING              = 8,
    TAG_FIELDREF            = 9,
    TAG_METHODREF           = 10,
    TAG_INTERFACEMETHODREF  = 11,
    TAG_NAMEANDTYPE         = 12,
    TAG_METHODHANDLE_INFO   = 15,
    TAG_METHODTYPE          = 16,
    TAG_INVOKEDYNAMIC       = 18
}

struct ConstantPoolInfo {
    ConstantPoolTag tag; // TODO: Shall be an enumeration
}

struct JVMClass {
    uint:32 magic; // <format=hex> must be 0xCAFEBABE
    uint:16 minor_version;
    uint:16 major_version;
    uint:16 constantPoolSize;
    ConstantPoolInfo constantPool[constantPoolSize];
}

/*
typedef struct {
    u2 minor_version;
    u2 major_version;
    u2 constant_pool_count;
    cp_info constant_pool[constant_pool_count-1];
    AF access_flags;
    u2 this_class;              // Reference into constant_pool table
    if (this_class < 1 || this_class > constant_pool_count-1) {
        local string s;
        SPrintf(s,"Bad 'this_class' reference (%d).  It should be in the range [1..%d]", this_class, constant_pool_count-1);
        Warning(s);
        return -2;
    }
    u2 super_class;             // Reference into constant_pool table
    if (super_class < 1 || super_class > constant_pool_count-1) {
        local string s;
        SPrintf(s,"Bad 'super_class' reference (%d).  It should be in the range [1..%d]", super_class, constant_pool_count-1);
        Warning(s);
        return -2;
    }
    u2 interfaces_count;
    u2 interfaces[interfaces_count];
    u2 fields_count;
    field_info fields[fields_count];
    u2 methods_count;
    method_info methods[methods_count];
    u2 attributes_count;
    attribute_info attributes[attributes_count];
} JVMClass <read=read_JVMClass, optimize=false>;

*/